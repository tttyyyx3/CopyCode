#include "stdAfx.h"
#include "CFindWindow.h"

CFindWindow::CFindWindow(void)
:m_hWnd(NULL), m_classname(NULL)
{
}

CFindWindow::~CFindWindow(void)
{
}

void CFindWindow::FindWin(HWND hwndParent, LPCSTR classname)
{
m_hWnd=NULL;
m_classname=classname;
FindChildClassHwnd(hwndParent,LPARAM(this));
}

BOOL CALLBACK CFindWindow::FindChildClassHwnd(HWND hwndParent,LPARAM lParam)
{
    CFindWindow *pfw = (CFindWindow*)lParam;
    HWND hwnd = FindWindowEx(hwndParent, NULL, pfw->m_classname, NULL);
    if (hwnd) {
        pfw->m_hWnd = hwnd;
        return FALSE; //停止枚举 并返回
    }
    EnumChildWindows(hwndParent, FindChildClassHwnd, lParam); //枚举所有子窗口
return TRUE;
};




	*syj_find 遍历数据库函数
*/
static void ArxProject2syj_find(void)
{
// Add your code for command ArxProject2.syj_find here
//打开数据库并迭代遍历其中的实体.
AcDbObjectId objId;
AcDbDatabase * pDb = acdbHostApplicationServices()->workingDatabase();
AcDbBlockTable *pBlockTable =NULL;
pDb->getBlockTable(pBlockTable, AcDb::kForRead);
AcDbBlockTableRecord *pBlockTableRecord =NULL;
pBlockTable->getAt(ACDB_MODEL_SPACE,pBlockTableRecord, AcDb:: kForRead);
pBlockTable->close();
//迭代器
AcDbBlockTableRecordIterator *pIter = NULL;
pBlockTableRecord->newIterator(pIter); // Create an iterator
for (pIter->start(); !pIter->done(); pIter->step())
{

AcDbEntity *pEntity = NULL;
if (pIter->getEntity(pEntity, AcDb::kForRead) != Acad::eOk)
continue;
if(pEntity->isKindOf(AcDbCircle::desc()))
objId = pEntity->objectId();
}
pBlockTableRecord->close();
}



	GetDlgItemText(IDC_EDITPARAM,m_strParam);
GetDlgItemText(IDC_EDITRUNDIR,m_strRunDir);


	CFileDialog	dlg(TRUE,_T(".exe"),NULL,OFN_DONTADDTORECENT | OFN_ENABLESIZING | OFN_FORCESHOWHIDDEN | OFN_HIDEREADONLY,
_T("可执行文件 (*.exe)|*.exe|所有文件 (*.*)|*.*||"),this);
if (dlg.DoModal() != IDOK)
{
return;
}

CString strExePath(dlg.GetPathName());
SetDlgItemText(IDC_EDITFILEPATH,strExePath);

SetDlgItemText(IDC_EDITRUNDIR,strExePath.Left(strExePath.ReverseFind('\\')+1));




进程快照


	HANDLE hToolhelp = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
if (hToolhelp == INVALID_HANDLE_VALUE)
{
this->MessageBox(_T("获取进程快照失败"));
return	TRUE;
}
PROCESSENTRY32	stProcess = {0};
stProcess.dwSize = sizeof(PROCESSENTRY32);
Process32First(hToolhelp, &stProcess);
for (int i=0;Process32Next(hToolhelp, &stProcess);i++)
{
TCHAR	pszPid[10];
_itot_s(stProcess.th32ProcessID, pszPid,10);
//m_ListProcess.SetItemText(i,0,pszPid);
m_ListProcess.InsertItem(i, pszPid, NULL);
m_ListProcess.SetItemText(i,1,stProcess.szExeFile);
HANDLE	hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, stProcess.th32ProcessID);
TCHAR	pszProcessPath[MAX_PATH+2];
if (GetModuleFileNameEx(hProcess, NULL, pszProcessPath, MAX_PATH+2))
{
m_ListProcess.SetItemText(i, 2, pszProcessPath);
}
CloseHandle(hProcess);
}
CloseHandle(hToolhelp);

HANDLE hProcess=GetCurrentProcess();
