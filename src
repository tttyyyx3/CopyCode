#include "stdAfx.h"
#include "CFindWindow.h"

CFindWindow::CFindWindow(void)
:m_hWnd(NULL), m_classname(NULL)
{
}

CFindWindow::~CFindWindow(void)
{
}

void CFindWindow::FindWin(HWND hwndParent, LPCSTR classname)
{
m_hWnd=NULL;
m_classname=classname;
**FindChildClassHwnd(hwndParent,LPARAM(this));**
}

BOOL CALLBACK CFindWindow::FindChildClassHwnd(HWND hwndParent,LPARAM lParam)
{
    CFindWindow *pfw = (CFindWindow*)lParam;
    HWND hwnd = FindWindowEx(hwndParent, NULL, pfw->m_classname, NULL);
    if (hwnd) {
        pfw->m_hWnd = hwnd;
        return FALSE; //停止枚举 并返回
    }
    EnumChildWindows(hwndParent, FindChildClassHwnd, lParam); //枚举所有子窗口
return TRUE;
};




	*syj_find 遍历数据库函数
*/
static void ArxProject2syj_find(void)
{
// Add your code for command ArxProject2.syj_find here
//打开数据库并迭代遍历其中的实体.
AcDbObjectId objId;
AcDbDatabase * pDb = acdbHostApplicationServices()->workingDatabase();
AcDbBlockTable *pBlockTable =NULL;
pDb->getBlockTable(pBlockTable, AcDb::kForRead);
AcDbBlockTableRecord *pBlockTableRecord =NULL;
pBlockTable->getAt(ACDB_MODEL_SPACE,pBlockTableRecord, AcDb:: kForRead);
pBlockTable->close();
//迭代器
AcDbBlockTableRecordIterator *pIter = NULL;
pBlockTableRecord->newIterator(pIter); // Create an iterator
for (pIter->start(); !pIter->done(); pIter->step())
{

AcDbEntity *pEntity = NULL;
if (pIter->getEntity(pEntity, AcDb::kForRead) != Acad::eOk)
continue;
if(pEntity->isKindOf(AcDbCircle::desc()))
objId = pEntity->objectId();
}
pBlockTableRecord->close();
}



	GetDlgItemText(IDC_EDITPARAM,m_strParam);
GetDlgItemText(IDC_EDITRUNDIR,m_strRunDir);


	CFileDialog	dlg(TRUE,_T(".exe"),NULL,OFN_DONTADDTORECENT | OFN_ENABLESIZING | OFN_FORCESHOWHIDDEN | OFN_HIDEREADONLY,
_T("可执行文件 (*.exe)|*.exe|所有文件 (*.*)|*.*||"),this);
if (dlg.DoModal() != IDOK)
{
return;
}

CString strExePath(dlg.GetPathName());
SetDlgItemText(IDC_EDITFILEPATH,strExePath);

SetDlgItemText(IDC_EDITRUNDIR,strExePath.Left(strExePath.ReverseFind('\\')+1));




进程快照


	HANDLE hToolhelp = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
if (hToolhelp == INVALID_HANDLE_VALUE)
{
this->MessageBox(_T("获取进程快照失败"));
return	TRUE;
}
PROCESSENTRY32	stProcess = {0};
stProcess.dwSize = sizeof(PROCESSENTRY32);
Process32First(hToolhelp, &stProcess);
for (int i=0;Process32Next(hToolhelp, &stProcess);i++)
{
TCHAR	pszPid[10];
_itot_s(stProcess.th32ProcessID, pszPid,10);
//m_ListProcess.SetItemText(i,0,pszPid);
m_ListProcess.InsertItem(i, pszPid, NULL);
m_ListProcess.SetItemText(i,1,stProcess.szExeFile);
HANDLE	hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, stProcess.th32ProcessID);
TCHAR	pszProcessPath[MAX_PATH+2];
if (GetModuleFileNameEx(hProcess, NULL, pszProcessPath, MAX_PATH+2))
{
m_ListProcess.SetItemText(i, 2, pszProcessPath);
}
CloseHandle(hProcess);
}
CloseHandle(hToolhelp);

HANDLE hProcess=GetCurrentProcess();



void change_file_date(const char *filename, uLong dosdate, tm_unz tmu_date)
{
   HANDLE hFile;
   FILETIME ftm, ftLocal, ftCreate, ftLastAcc, ftLastWrite;
   hFile = CreateFileA(filename, GENERIC_READ | GENERIC_WRITE,
      0, NULL, OPEN_EXISTING, 0, NULL);
   GetFileTime(hFile, &ftCreate, &ftLastAcc, &ftLastWrite);
   DosDateTimeToFileTime((WORD)(dosdate >> 16),(WORD)dosdate, &ftLocal);
   LocalFileTimeToFileTime(&ftLocal, &ftm);
   SetFileTime(hFile, &ftm, &ftLastAcc, &ftm);
   CloseHandle(hFile);
}





ClipBoardMonitor::ClipBoardMonitor(void)
:m_lock(false)
{
}


ClipBoardMonitor::~ClipBoardMonitor(void)
{
}

void ClipBoardMonitor::StartMonitor()
{
 CreateTimerQueueTimer(&m_timer,NULL,OnTimer,this,0,1000,0);	
}
#define BUFFER 1024
VOID CALLBACK ClipBoardMonitor::OnTimer(LPVOID p , BOOLEAN){
ClipBoardMonitor* a=(ClipBoardMonitor*)p;
if(!a->m_lock)
{
a->m_lock=true;
char buffer[BUFFER];

OpenClipboard(NULL);
HANDLE h= GetClipboardData(CF_TEXT);
::GlobalLock(h);
char* c=(char*)h;
strcpy_s(buffer,c);
::GlobalUnlock(h);	
wchar_t ws[BUFFER];
swprintf(ws, BUFFER, L"%hs", buffer);
MessageBox(NULL,ws,L"TEXT",0);
a->m_lock=false;
}
}

void ClipBoardMonitor::StopMonitor()
{
//::SetWindowsHookEx(WH_
}
